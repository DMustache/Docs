[Back](../README.md)

---

# Integer

Целое чилоо без дробной части. Бывает 2 типа: `i`(с знаком) и `u`(без знака)

| количество бит 	| Со знаком 	| Без знака 	|
|----------------	|-----------	|-----------	|
| 8              	| i8        	| u8        	|
| 16             	| i16       	| u16       	|
| 32             	| 132       	| u32       	|
| 64             	| i64       	| u64       	|
| 128            	| i128      	| u128      	|
| arch           	| isize     	| usize     	|

границы для знаковых значений вычисляются по формулам: от -(2^n-1^) до 2^n-1^ - 1
границы для беззнаковых значений вычисляются по формуле от 0 до 2^n^ - 1
Целочисленные литералы можно записывать в любой из форм представленных ниже:

| Числовые литералы | Пример      |
|----------------	|-------------|
| Десятичный	    | 98_222      |
| Шестнадцатеричный | 0xff        |
| Восьмеричный	    | 0o77        |
| Двоичный	        | 0b1111_0000 |
| Байт (только u8)  | b'A'        |

Основной случай, когда требуется использовать `isize` и `usize` - индексация какой-либо коллекции.

## Переполнение целых чисел
если для переменной `u8`, что включает от 0 до 255 попытаться вписать 256, то возникнет паника при компиляции в режиме отладки `cargo build`. Но если запустить сборку с `--release`, то ошибка не появится. В этом случае, число, больше допустимого станет остатком на деление от допустимого. Так, число 256, хранящееся в `u8` станет 1.
Если требуется достичь переполнения в программе, то стоит использовать следующие методы:
- `wrapping_*`, например `wrapping_add`
- Возвращение другой переменное, если `checked_*` сработал.
- Возвращение числа и логического значения, с помощью `overflowing_*`.
- Установить минимальное или максимальное значение при использовании методов `saturating_`.

---

# Float

Числа с плавающей запятой могут быть только `f32` и `f64`. `f32` работает быстрее ненамного, а `f64` будет более точным.
Числа с плавающей точкой представлены согласно стандарту [IEEE-754](https://ru.wikipedia.org/wiki/IEEE_754-2008). Тип `f32` является числом с плавающей точкой одинарной точности, а `f64` имеет двойную точность.
![сравнение точности f32 и f64](https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/IEEE754.svg/446px-IEEE754.svg.png)

## Числовые операции

Rust поддерживает основные математические операции, которые ожидаются для всех типов чисел: сложение(`+`), вычитание(`-`), умножение(`*`), деление(`/`) и остаток(`%`). Целочисленное деление округляется до ближайшего целого числа.

---

# Bool

В rust логический тип данных занимает 1 байт, обозначается как `bool` и принимает значения: `true` и `false`.

---

## Char

Примитивный алфавитный тип языка. Может принимать любой один символ. Символ оборачивается одинарными кавычками. занимает 4 байта. Обозначается `char`. Скалярные значения Unicode находятся в диапазоне от `U+0000` до `U+D7FF` и от `U+E000` до `U+10FFFF` включительно.

---

## String

В rust есть строка `str`, который обычно используется как `&str`, что на самом деле является строковым срезом.
Тип `String` предоставляется стандартной библиотекой rust. Такая строка является изменяемой. Обе строки кодируются в `UTF-8` кодировке. Оборачиваются в двойные кавычки. Строка фактически реализованна как обертка вектора байт с некоторыми изменениями.

```Rust
let mut string_new = String::new();
```

Пример создания пустой строки.

- `str` - самый примитивный строковый тип. Напрямую к нему получить доступ нельзя, так как `str` динамический тип.
- `&str` - отличается от `str` тем, что состоит из двух компонентов: _указателя на несколько байтов_ и _длины_. Является неизменной
- `String` - строка, размещенная в куче, он может увеличиваться, а так же всегда в кодировке `UTF-8`. Конвертация `String` в `&str` является дешевой конвертацией, но конвертация `&str` в `String` требует выделения памяти. Не стоит так делать, если нет на то причин.
- Смена `String` в `&str` принудительно происходит с помощью &. Однако, в некоторых функциях требуется использовать `&*`.

### Appendix

- [doc.rust-lang.org](https://doc.rust-lang.org/std/string/struct.String.html)
- [web.mit.edu](https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/book/first-edition/strings.html)
- [habr.com](https://habr.com/ru/post/274485/)

---

## Tuples
Кортеж используется для группировки нескольких значений. Имеет фиксированную длину. Задается с помощью записи списка значений в круглых скобках. Чтобы получить значения из кортежа можно перечислить в инициализации в скобках, каким переменным какие значения подставить.
Чтобы обратиться к одному элементу надо через точку указать, под каким индексом надо брать переменную

```Rust
fn main() {
    let tup = (1, 2, 3, (4, 5, 6));
    let (x, y, z, (a, b, c)) = tup;
    println!("{} {} {} {} {} {}", x, y, z, a, b, c);
    let indexed = tup.3.1;
    print!("{}", indexed);
}
```

Пустой кортеж имеет имя `unit`.

## Array

Другой способ собрать несколько значений, в отличие от кортежа, массив состоит одинаковых типов данных. Но так же имеет ограниченную длину. Значения хранятся в стеке.

Пример задания массива:

```Rust
fn main() {
    let days_of_week = ["Понедельник", "Вторник", "Серда", "Четверг", "Пятница", "Суббота", "Воскресенье"];
    let triple_six = [3;6];
}
```

Чтобы, допустим, обратиться к вторнику из массива `days_of_week`, надо использовать `days_of_week[1]`

## О неразмерных типах

Большинство типов в rust имеют некий размер, но допустим строки безразмерны так как мы не знаем, сколько будет отведено например на приложение: _Как прекрасны эти спелые яблоки._
Вот 3 ограничения, которые есть в rust относительного этого типа:
* Можно манипулировать только с помощью указателя "&".
* Переменные или аргументы не могут иметь типы с динамическим типом.
* Только последнее поле в `struct` может иметь тип с динамическим размером в качестве данных.

Это позволяет избежать записи типа:

```Rust
impl Foo for &str {
```

Вместо этого можно писать так:

```Rust
impl Foo for str {
```

или

```Rust
impl<T> Foo for [T] {
```

Эта реализация будет работать только для ссылок, а не для других типов указателей.

Если вы хотите написать функцию, которая принимает тип с динамическим размером, вы можете использовать специальный синтаксис привязки `?Sized`:

```Rust
struct Foo<T: ?Sized> {
    f: T,
}
```

Это `?Sized` читается как «T может быть или не быть `Sized`», что позволяет нам сопоставлять как размерные, так и неразмерные типы. Все параметры универсального типа неявно имеют `Sized` привязку, поэтому `?Sized `можно использовать для отказа от неявной привязки.

---