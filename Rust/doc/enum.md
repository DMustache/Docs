[Back](../README.md)

# Enum

В то время как структуры позвооляют нам группировывать поля и данные, перечисления позволяют нам использовать как один из реализованных наборов значений:

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

Так как в rust нет состояние переменных `null`, что является способом защиты от неправильного поведения кода, в некоторых моментах `null` бывает полезен, а именно: обозначение недействительности значения в данный момент по некой причине. В rust есть реализация пустого значения - перечисление. Это `Option<T>`:

```rust
enum Option<T> {
    None,
    Some(T),
}
```

## Option

Оно настолько полезно, что включено неявно, его вариации так же включены по умолчанию, даже без префикса `Option<T>`. Чтобы работать с значениями, хранящимися в `Option`, надо использовать конструкцию `match`:

```rust
fn plus_n(x: Option<i32>, n:i32) -> Option<i32> {
    match x {
        None => return None,
        Some(i) => return Some(i + n),
    }
}

fn main() {
    let five = Some(5);
    println!("{:?}", plus_n(five, 5)); //Some 10
}
```


## Enum and match

Если не использовать в шаблоне `match` все варианты для используемого `enum`, то копилятор нам подскажет, что было-бы не плохо реализовать остальные случаи.

## Explicit let if in match

`if let` позваляет комбинировать ветвление и инициализацию. Из-за этого код будет менее читабельным, но позволит игнорировать другие реализации:

```rust
let config_max = Some(32i8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max); // 32
```

По сути, `if let` можно представить как синтаксическй сахар для `match`, который менее читабельный и безопасный, не кго быстрее реализовать.

## Universal parameters in match

В предыдущем примере использовалась `i` для универсального случая. Это позволяет избаиться от жестко закодированных одинаковых реализаций. Имя случайного входного параметра может буть любым, не мешающим rust

---
