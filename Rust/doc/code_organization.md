[Back](../README.md)

---

# Code Organization

По мере развития проекта становится неудобно все держать в одном файле: Его становится трудно просматривать, возникают проблемы с одинаковым названием функций и все превращается в кашу, чтобы этого избежать, код разносят по разным файлам.

Код может содержать несколько модулей, файлов, возможно бинарных крейтов и один библиотечный крейт. По мере роста проекта, вы можете извлекать отдельные части в отдельные контейнеры, которые становятся внешними зависимостями.

* **Пакеты**: функция Cargo, которая позволяет создавать, тестировать и делиться крейтами.
* **Крейты**: дерево модулей, которое создает библиотеку или исполняемый файл.
* **Модули, use**: позволяют контролировать организацию, видимость и приватность путей.
* **Пути**: способ именования элемента, такого как структура, функция или модуль.

---

## Packages and crates

Крейт - наименьший объем кода, который компилятор рассматривает за раз, даже если происходит запуск через rustc, а не cargo, вы передаете один файл компилятору, который компилятор рассматривает это за один крейт. Крейты могут содержать модули как в одном файле, так и во многих. Все модули компилируются вместе с крейтом. Крейт может быть как бинарник и как библиотека. __Бинарный крейт__ - программа, которую вы можете например запускать через командную строку. У каждого бинарного крейта должна быть функция `main`, которая определяет точку входа для программы.

Библиотечный крейт - крейт, который не имеет функции `main` и не может быть скомпилирован в исполняемый файл так как при запуске его не понятно, какой модуль необходимо запускать. Крейт по сути является библиотекой относительно общей концепцией программирования.

Кореневой модуль крейта - исходный файл, из которого компилятор rust начинает собирать корневой модуль крейта.

Пакет - набор из одного или нескольких крейтов, представляющий набор функциональности. Пакет содержит файл `Cargo.toml`, в котором описывается, как собирать крейты. На самом деле, Cargo - пакет , содержащий бинарный крейт для инструмента командной строки. Пакет Cargo так же содержит библиотечный крейт, от которого зависит бинарный крейт. Пакет может содержать сколько угодно бинарных крейтов, но не более одного библиотечного крейта. Пакет должен содержать хотя бы один крейт: библиотечный или бинарный.

Например при создании проекта через `cargo new project` мы увидим следующее:

```pwsh
$ cargo new project
$ tree project
```

```
project/
├── Cargo.toml
└── src
    └── main.rs
```

`Cargo.toml` - наш проект, это пакет.
`src/main.rs` - модуль бинарного крейта.

# Scope on modules

* Корень крейта: при компиляции компилятор сначала ищет корневой модуль крейта(обычно это __`src/lib.rs`__ для библиотечного крейта или __`src/main.rs`__ для бинарного крейта)
* Объявление модулей: В файле корневого модуля крейта вы можете объявить новые модули, например, мы объявили модуль **garden** с помощью `mod garden;`, компилятор будет искать код модуля в следующих местах:
  * в этом же файле, между фигурных скобок, которые заменяю точку с запятой после `mod garden`
  * в файле __`src/garden.rs`__
  * в файле __`src/garden/mod.rs`__
* Подмодули: в любом файле, кроме корневого модуля крейта модно объявить подмодули. К примеру, можно объявить `mod vegetables` в __`src/garden.rs`__. Компилятор будет искать код подмодуля в каталоге с именем родительского модуля в следующих местах:
  * в этом же файле после `mod vegetables`, между фигурных скобок, которые заменяют точку с запятой.
  * в файле __`src/garden/vegetables.rs`__
  * в файле __`src/garden/vegetables/mod.rs`__
* Пути к коду в модулях: после того, как модуль станет частью крейта и если позволяют правила приватности, вы можете ссылаться на код в этом модуле из любого места крейта, используя путь к коду. Например тип `Asparagus` в подмодуле `vegetables` модуля `garden` будет найден по пути `crate::garden::vegetables::Asparagus`
* Сокрытие или общедоступность: Код в модуле по умолчанию приватен от внешнего кода. Чтобы публичный код модуля был доступен, надо при импорте его добавить `pub`
* `use`: Внутри области видимости использование `use` создаст псевдонимы для элементов, чтобы уменьшить повторение длинных путей. В любой области видимости использование `use` создаст псевдонимы для элементов, чтобы сократить длинные пути. Допустим, если мы раньше использовали `crate::garden::vegetables::Asparagus`, то после того, как добавим `use`: `use crate::garden::vegetables::Asparagus;`, достаточно будет использовать `Asparagus`.

## Группировка связанного кода в модулях

Модули позволяют упорядочить код внутри крейта для удобочитаемости и легкого повторного использования. Модули так же позволяют управлять приватностью его элементов, поскольку код внутри модуля по умолчанию является закрытым. Частные элементы - внутренние детали реализации, недоступные для внешнего использования. Мы можем сделать модули и элементы внутри них общедоступными, что позволит нашему коду использовать их и зависеть от них.

## Пути для ссылки на элемент в дереве модулей

Чтобы показать rust, где хранится нам нужный элемент в дереве модулей, мы используем путь так же, как мы используем путь при навигации по файловой системе. Чтобы вызвать функцию, нам нужно знать ее путь.

Бывают 2 вида путей: __абсолютный__(`crate`) и __относительный__(`self/super`) и вместо `/` используется `::`

### Использование `super` в относительном пути.

Так же можно построить относительные пути, которые начинаются в родительском модуле, используя `super` в начале пути. Это похоже на синтаксис начала пути файловой системы `..`. Использование `super`  позволяет нам сослаться на элемент, который, как мы знаем, находится в родительском модуле, что может упростить переупорядочивание дерева модулей, чем когда модуль тесно связан с родителем, но родитель может когда-нибудь переместиться в другое место.

### Использование `use`

**[Не является операцией включения](https://doc.rust-lang.ru/book/ch07-05-separating-modules-into-different-files.html#%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9-%D0%BD%D0%B0-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D0%B5-%D1%84%D0%B0%D0%B9%D0%BB%D1%8B), просто показывает, где находится используемый код**

Постоянно писать полные пути до реализаций бывает не совсем приятно, для того, чтобы от этого избавится используют слово `use`. Использование `use` аналогично использованию символической ссылки в файловой системе, мы можем обращаться к адресату как через ссылку, так и через относительный путь, так и через абсолютный путь.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

Когда нам необходимо использовать функции с одинаковым именем, но в разных библиотеках, мы можем либо указать их дочернии элементы, либо использовать `as`, которая даст возможность нам переименовать импорт так, как мы хотим.

### Реэкспорт имен с `pub` `use`

Когда мы подключаем имя в область видимости, используя ключевое слово `use`, то имя, доступное в новой области видимости является приватным. Чтобы позволить коду, который вызывает наш код, ссылаться на это имя, как если бы оно было определено в области видимости данного кода, можно объединить `pub` и `use`. Этот метод называется реэкспортом, потому что мы подключаем метод в область видимости, но так же делаем этот элемент доступным для подключения в других областях видимости.

То есть если использовать `use`, то еог нельзя будет использовать из внешнего модуля, `pub` это исправляет.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

### Использование вложенных путей `use`

Если мы используем несколько элементов одного крейта одного модуля, то для того чтобы не повторять пути, мы можем на уровне последнего элемента поставить фигурные скобки и экспортировать необходимые модули:

```rust
use rand::Rng;
// --snip--
use std::cmp::Ordering;
use std::io;
// --snip--
```

```rust
use rand::Rng;
// --snip--
use std::{cmp::Ordering, io};
// --snip--
```

Чтобы использовать во вложенном пути помимо продолжения пути еще и родительский путь, можно использовать `self`

```rust
use std::io::{self, Write};
```

Это позволяет использовать как `std::io` и `std::io::Write` в области видимости.

Чтобы использовать все в пределах пути, используют `*` `(glob)`


## Пример

Напишем библиотечный крейт, предоставляющий возможности ресторана.

В ресторанной индустрии некоторые части называет фронтом дома, а другие - беком дома. Фронт - место, где находятся клиенты, здесь размещаются места клиентов, официанты разносят еду. Бек - кухня где происходит приготовление еды.

Чтобы структурировать крейт подобно ресторану, можно организовать функции во вложенных модулях.

```
$ cargo new restaurant --lib
```

```rust
// src/lib.rs
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

Модуль определяется ключевым словом `mod`, затем идет название. Модули так же могут содержать определения для других элементов: структуры, перечисления, константы, типажи, функции. Используя модули, мы можем сгруппировать связанные определения вместе и сказать, почему они являются связанными. Программистам будет легче найти необходимую реализацию в сгруппированном коду, вместо того чтобы искать ее в общем списке. Программисты, добавляющие новые реализации будет знать, где разместить код для поддержания порядка проекта.

Для того, чтобы понять, как будут выглядеть пути до реализаций, посмотрим на следующее дерево:

```
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

Это дерево напоминает дерево каталога. И это правильно, ведь именно там относительно `crate/src` будут храниться нам необходимые модули.

Покажем 2 способа вызова функции `add_to_waitlist` из `eat_at_restaurant`, определенной в корне проекта. Функция `eat_at_restaurant` является частью общедоступного APi библиотечного крейта, поэтому мы обозначим ее `pub`

В rust, с целью безопасности, все реализации являются приватными, по этому, для того, чтобы получить реализацию из другого модуля, необходимо удостовериться в том, что она является публичной.

Элементы в родительском модуле не могут получить приватные внутри дочерних модулей, но элементы в дочерних модулях могут использовать элементы в своих модулях-родителях. Это связанно с тем, что дочерние модули оборачивают и скрывают свои реализации, но дочерние модули могут видеть контекст своих родителей.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}

        fn seat_at_table() {}
    }


    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}

pub fn eat_at_restaurant() {
    crate::front_of_house::hosting::add_to_waitlist();

    front_of_house::hosting::add_to_waitlist();
}
```

Так как еда готовится на кухне, то там реализуем `Breakfast`, который можно заказать в `eat_at_restaurant`

```
mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &str) -> Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from("blueberries");
}
```

В данном примере структура `Breakfast` имеет приватное поле, то для создания его экземпляра должна существовать публичная функция. В данном примере это `summer` так как зимой персиков нет.

В отличии от структуры, если мы сделаем общедоступным перечисление, то все его варианты будут общедоступными. Нужно только указать `pub` перед ключевым словом `enum`

# Разделение модулей на разные файлы

Перепишем наш проект ресторана.

__src/lib.rs__
```rust
mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {

}
```

__src/front_of_house.rs__
```rust
pub mod hosting{
    pub fn add_to_waitlist() {}
}
```

Далее извлечем `hosting` в другой файл

__src/front_of_house/hosting.rs__
```rust
pub fn add_to_waitlist() {}
```

Так, дерево модулей осталось прежним, а работать стало проще.

---