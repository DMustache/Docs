[Back](../README.md)

# Collections

Стандартная библиотека коллекций rust обеспечивает эффективную реализацию наиболее распространенных структур данных общего назначения. При использовании стандартных реализаций, две библиотеки должны без проблем обмениваться данными без значительного их преобразования. Чтобы решить эту проблему, обычно достаточно `Vec` или `HashMap`. Эти две коллекции являются наиболее популярными и предоставляют большинство вариантов хранения и обработки данных. Несмотря на это, у каждой коллекции в стандартной библиотеке есть определенные варианты использования, в которых они будут наиболее оптимальными для использования.

---

# When Should You Use Which Collection?

* `Vec`
  * Требуется собирать элементы для обработки или отправки в другое место позже, не заботясь при этом о свойствах сохраняемых значений.
  * Нужна последовательность элементов в определенном порядке. Элементы необходимо сохранять в конец или почти конец вектора.
  * Нужен стек.
  * Нужен изменяемый массив.
  * Нужен массив с выделенной кучей
* `VecDeque`
  * Нужен `Vec`, который может сохранять элементы на обоих своих концах.
  * Нужна очередь
  * Нужна двухсторонняя очередь (dequeue)
* `LinkedList`
  * Нужен `Vec` или `VecDeque`, при этом не нужна амортизация.
  * Требуется эффективно разделить и добавить списки.
  * Без [двусвязного](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA#%D0%94%D0%B2%D1%83%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_(%D0%B4%D0%B2%D1%83%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D1%8B%D0%B9_%D1%81%D0%BF%D0%B8%D1%81%D0%BE%D0%BA)) списка не обойтись.
* `HashMap`
  * Требуется связать произвольные ключи с произвольным значением.
  * Нужен кеш
  * Нужна карта без дополнительных функций
* `BTreeMap`
  * Нужна карта, отсортированная по ключам.
  * Требуется возможность получать ряд значений по запросу.
  * Интересует наименьшая/наибольшая пара ключ-значение.
  * Требуется получать доступ к самому большому или самому маленькому ключу, который больше или меньше чего-либо.
* `Set` любого варианта
  * Требуется вспомнить, какие ключи были использованы.
  * Нет никакой значимой информацииЮ которую можно связать с ключами.
  * Требуется набор.
* `BinaryHeap`
  * Требуется хранить множество элементов, но работать только с самыми большими из них
  * Требуется приоритет элементов.

# Performance

В зависимости от выбранной коллекции, программа будет работать с разной производительностью

## Sequences

|| get(i) | insert(i) | remove(i) | append | split_off(i) |
|--------|-----------|-----------|--------|----------|--------------|
| `Vec` | O(1)| O(n-i)* | O(n-i) | O(m)* | O(n-i) |
| `VecDeque` | O(1) | O(min(i, n-i))* | O(min(i, n-i)) | O(m)* | O(min(i, n-i)) |
| `LinkedList` | O(min(i, n-i)) | O(min(i, n-i))|O(min(i, n-i)) | O(1) | O(min(i, n-i)) |

Важно. Там, где возникают связи, `Vec` обычно работает быстрее остальных. Так же `VecDeque` обычно быстрее `LinkedList`.

## Maps

|| get | insert | remove | range | append |
|--- |--- |--- |--- |--- |--- |
| `HashMap` | О(1)~ | О(1)~* | О(1)~ | N/A | N/A |
| `BTreeMap` | О(log(n))| О(log(n)) | О(log(n)) | О(log(n)) | О(n+m) |

# Correct and Efficient Usage of Collections

Знание того, какая коллекция подходит лучше для работы не позволяет сразу же использовать ее правильно. Для того, чтобы окончательно выбрать необходимую коллекцию, требуется обратиться к документации к выбранным коллекциям для подробного разбора и примеров кода.

# Capacity Management

Многие коллекции предоставляют несколько конструкторов методов, которые ссылаются на "емкость". Эти коллекции обычно строятся поверх массива. Оптимально, чтобы этот массив был точно такого-же массива, чтобы вмещать только элементы, хранящиеся в коллекции, но для коллекции это было бы не очень эффективно. Если бы резервный массив всегда был точно требуемого на данный момент размера, то каждый раз, когда элемент встраивается, коллекция должна была бы увеличить массив, чтобы соответствовать ему. Из-за того, как память распределяется и управляется на большинстве компьютеров, это почти наверняка потребует выделения совершенно нового массива и копирования каждого отдельного элемента старого массива в новый.

Именно из-за этого, в большинстве коллекций используется стратегия амортизированного распределения. Как правило, она позволяет иметь изрядное количество незанятой памяти, так что им приходится расти только изредка. Когда коллекция растет, она выделяет занимает значительно больший массив для перемещения элементов, так что потребуется некоторое время, чтобы потребовалось заново резервировать память под коллекцию. Хотя эта стратегия шикарно себя ведет, было бы лучше, если бы коллекциям никогда не приходилось изменять размер массива. К сожалению, коллекциям недостаточно информации, чтобы решить эту проблему. По этому, коллекции надо давать подсказки.

Любой `with_capacity` конструктор даст указание коллекции выделить достаточно места для указанного количества элементов. В идеале выделится место для указанного количества элементов, но некоторые детали реализации могут помешать этому. Для подробной информации необходимо знать тонкости используемой коллекции. Для разумного использования `with_capacity` требуется знать разумное верхнее значение количества элементов коллекции.

Когда требуется заполнить резко коллекцию большим количеством элементов, можно использовать семейство методов `reserve`, что указать коллекции, сколько места коллекция должна освободить для поступающих элементов. Как и в случае с `with_capacity`, точное поведение этих методов будет зависть от интересующей коллекции.

Для достижения оптимальной производительности, коллекции, как правило, не сжимаются. Если все же требуется уменьшить размер коллекции, то метод `shrink_to_fit` позволяет уменьшить размер коллекции до минимума.

Если требуется узнать емкость коллекции, большинство коллекций имеют метод `capacity`. Этот метод полезен в связке с `reserve` методами.

# Iterators

Итератор - мощный и надежный механизм, используемый во всех стандартных библиотеках Rust. Итераторы предоставляют последовательность значений универсальным, безопасным, эффективным и удобным способом. Содержимое итератора обычно оценивается лениво, так что фактически создаются только те значения, которые действительно необходимы. и для их временного хранения не требуется выделения памяти. Итераторы в основном используются с циклом `for`, хотя многие функции так же используют итераторы, когда требуется набор или последовательность значений.

Все стандартные коллекции предоставляют несколько итераторов для выполнения массовых операций с их содержимым. Почти каждая коллекция предоставляет три основных итератора: `iter`, `iter_mut`, `into_iter`. Некоторые из них не представлены в коллекциях, если они являются небезопасными или неразумными для коллекции.

`iter` предоставляет итератор неизменяемых ссылок на все содержимое коллекции в наиболее естественном порядке. Для наборов последовательностей, таких как `Vec` это означает, что элементы будут выдаваться с 0. Для упорядоченных коллекций, таких как `BTreeMap` это значит, что элементы будут выдаваться в отсортированном порядке. Для неупорядоченных коллекций, таких как `HashMap`, элементы будут выдаваться в том порядке, в котором они более удобны для внутреннего представления. Это отлично подходит для чтения содержимого коллекции:

```rust
fn main() {
    let vector = vec![1,2,3,4,5];
    for i in vector.iter() {
        println!("{}", i);
    }
}
```

```
1
2
3
4
5
```

`iter_mut` предоставляет аналогичный итератор. Единственное отличие: ссылки изменяемые.

```rust
fn main() {
    let mut vector = vec![1,2,3,4,5];
    for i in vector.iter_mut() {
        *i += 1;
        println!("{}", i);
    }
}
```

```
2
3
4
5
6
```

`into_iter` преобразует коллекцию в итератор по ее содержимому. Это полезно, когда коллекция уже не нужна, а значения нужны в другом месте. Использование `extend` и `into_iter` - основной способ перемещения содержимого одной коллекции в другую. Оба метода должны внутри использовать инструменты управления емкостью, описанные выше, чтобы сделать это максимально эффективно. `T: IntoIterator collect`

```rust
fn main() {
    let mut vec1 = vec![1,2,3,4,5];
    let vec2 = vec![10, 20, 30, 40, 50];

    vec1.extend(vec2);

    for i in vec1.iter() {
        println!("{}", i);
    }
}
```

```
1
2
3
4
5
10
20
30
40
50
```

Итераторы имеют несколько адаптеров, которые позволяю взаимодействовать разным типам коллекций. Среди адаптеров есть такие фавориты, как `map`, `fold`, `skip`, `take` и `rev`. Особый интерес для коллекций представляет адаптер, который обращает любой итератор, поддерживающий этй операцию. Большинство коллекций предоставляют обратимые итераторы как способ перебора их в обратном порядке.

```rust
fn main() {
    let vec = vec![1,2,3,4];

    for i in vec.iter().rev() {
        println!("{}", i);
    }
}
```

```
4
3
2
1
```

Несколько других методов коллекции также возвращают итераторы для получения последовательных результатов, но избегают выделения всей коллекции для хранения результата. Это обеспечивает максимальную гибкость, так как `collect` и `extend` может быть вызвано для "конвейерной передачи" последовательности в любую коллекцию, если это необходимо. В противном случае последовательность может быть зациклена `for` циклом. Итератор также можно отбросить после частичного использования, что предотвратит вычисление неиспользуемых элементов.

# Entries

API `entry` предназначен для обеспечения эффективного механизма управления содержимым `Map` в зависимости от наличия ключа или нет. Основным мотивирующим вариантом использования этого является предоставление эффективных карт-хранилищ. Например, если кто-то хочет вести подсчет количества просмотров каждого ключа, ему придется выполнить некоторую условную логику относительно того, был ли ключ виден впервые или нет. Обычно для этого требуется, чтобы за `find` следовал `insert`, эффективно дублируя усилия по поиску при каждой вставке.

Когда вызывается `map.entry(key)`, `Map` будет искать ключ, а затем выдаст вариант перечисления `Entry`.

Если `Vacant(entry)` вернулся, то ключ не был обнаружен. В этом случае правильной будет только одна операция - `insert` значение в запись. После этого, свободная запись преобразуется в изменяемую ссылку на вставленное значение. Это позволяет в дальнейшем манипулировать значением за пределами времени существования искателя. Это полезно, если над значением требуется выполнить сложную логику независимо от того, было ло он только что вставлено.

Если `Occupied(entry)` получено, то ключ найден. В этом случае можно использовать `get`, `insert`, `remove`. Помимо этого можно изменить записанное значение, обеспечивая симметрию вакантного регистра.

---

## Sequences

### [Vec](https://doc.rust-lang.org/std/vec/struct.Vec.html)

Тип непрерывно расширяемого массива, реализующий тип подобный вектору.

#### `vec!`

Позволяет создавать вектор с заданными элементами, аналогичен `Vec::from([])`

```rust
fn main() {
    let mut vec1 = vec![1,2,3];
    vec1.push(4);

    let vec2 = Vec::from([1,2,3,4]);

    assert_eq!(vec1, vec2);
}
```

Так же можно создать сразу `n` значений, которые хранят `m`, для этого используется `vec![m; n]`, это лучше, чем выделение памяти, а затем заполнение

```rust
let mut vec = Vec::with_capacity(5);
vec.resize(5, 0);
```

Использование вектора в качестве стека:

```rust
fn main() {
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);

    while let Some(top) = stack.pop() {
        println!("{}", top);
    }
}
```

```
3
2
1
```

```rust
let v = vec![0, 2, 4, 6];
println!("{}", v[1]); // it will display '2'
```

#### Slice

Вектор может быть изменчивым, с другой стороны, срезы являются объектами только для чтения. Чтобы получить срез, требуется использовать `&`

```rust

fn read_slice(slice: &[usize]) {
    for i in slice.iter() {
        println!("{i}");
    }
}

fn main() {
    let vec = vec![0, 1];
    read_slice(&vec);

    let u: &[usize] = &vec;
    let u = &vec;
}
```

```
0
1
```

В Rust срезы передаются в качестве аргумента, а вектора, когда требуется предоставить доступ на чтение, аналогично `String` и `&str`

#### Capacity and reallocation

Емкость вектора - объем пространства, выделенного для любых будущих элементов, которые будут добавлены к вектору. Это не равно длине вектора, длина - количество используемых ячеек вектора. Если его величина превышает допустимое, то его вместимость будет автоматически увеличена, но его элементы потребуется перераспределить. По этому требуется использовать `with_capacity`, чтобы не потерять производительность важный момент.

#### Guarantees

Благодаря своему фундаменту, вектор дает много гарантий относительно его дизайна. Это гарантирует, чьл в общем случае накладные расходы будут минимальными. Помимо этого, гарантирует то, что можно правильно
манипулировать примитивными способами с помощью небезопасного кода. Эти гарантии относятся к неквалифицированному `Vec<T>`. Если добавляются дополнительные параметры типа, переопределение их значений по умолчанию может изменять их поведение.

`Vec` имеет указатель, емкость и длину. Порядок этих полей не определен, для использования каждого поля используются разные поля. Указатель никогда не будет нулевым, (но может указывать на пустое место) поэтому этот тип всегда оптимизирован для нулевого указателя.

Для пустых значений вектор не выделят в себе память. **Важно, в этом случае вектору может не сообщаться `capacity` значение 0**. Вектор будет выделать память только когда `mem::size_of::<T> * capacity() > 0`. В общем, детали реализации выделения очень тонкие, и если требуется выделить память в векторе а использовать для этого что-то по типу __небезопасного кода__, Проверяйте, что вы освободите когда-нибудь использованную память с помощью `from_raw_parts`, а только потом чистите переменную.

Вектор хранит свои данные в куче, указатель указывает на `len` инициализированные непрерывные элементы по порядку, за которым следуют `capacity - len` неинициализированные, непрерывные элементы.

Вектор можно представить как структуру, содержащую указатель на верхний элемент в куче, длину инициализированных элементов, емкость, доступную для заполнения этим вектором. Неинициализированные элементы представляются как `uninit`. см. [`MaybeUninit`](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html)
__Примечание: ABI(Двоичный интерфейс приложений) и вектор не дает никаких гарантий относительно своего расположения в памяти.__

Вектор никогда не будет выполнять маленькую оптимизацию, при которой элементы фактически хранятся в стеке по двум причинам:

* Небезопасному коду будет сложнее манипулировать с данными вектора. Содержимое `vec` не имело бы стабильного адреса, если бы было только перемещено, и было бы труднее определить, сколько памяти выделено под вектор.
* При каждом запросе к вектору, будет создаваться новая ветвь вызова.

Вектор никогда не будет автоматически уменьшаться, даже если он полностью пустой. Это избавит программу от ненужных выделений и освобождений памяти. Заполнение вектора новыми элементами вместо старых не должно приводить к дополнительным нагрузкам. Для того, чтобы изменить фактический размер вектора, можно использовать `shrink_to` для освобождения неиспользуемой памяти.

`push` и `insert` никогда не будет перераспределять память, если заявленная емкость достаточна. То есть, память, отведенная под вектор всегда точна и гарантирует безопасность.

```rust
fn main() {
    let a = vec![0; 5];
    let b = vec![1,2,3,4,5];
    let c: Vec<i32> = Vec::with_capacity(5);

    assert_eq!(a.capacity(), b.capacity());
    assert_eq!(b.capacity(), c.capacity());
}
```

Вектор никогда не будет специальной перезаписывать какие-=либо данные, которые будут удалены из него, но так же не будет специально сохранять их. Его память - свободное пространство, которое он может использовать по своему усмотрению. Как правило, вектор реализует свои методы максимально эффективно. Не стоит полагаться на удаление удаленных данных. Даже если вектор дропнется, его буфер может быть использован другим выделителен. Даже если память вектора будет преднамеренно обнулена, это может не произойти по той причине, что оптимизатор может посчитать это кэшем, который стоит сохранить. Однако есть один случай, который не стоит использовать: `unsafe` код при записи в избыточную память с последующим увеличением вектора для соответствия будет работать.

На данный момент вектор не гарантирует порядок удаляемых элементов, порядок удаления изменился в прошлом и может измениться в будущем.

### [VecDeque](https://doc.rust-lang.org/std/collections/struct.VecDeque.html)

Двусвязный вектор реализован с увеличивающимся кольцевым буфером. Использование _по умолчанию_ этого типа в качестве очереди заключается в `push_back` добавлении в конец и `pop_front` удалении вначале элементов. `extend` и `append` кладут элементы в конец, итерации `VecDeque` идут с первого элемента.

Двусвязный вектор можно инициализировать из массива. Поскольку `VecDeque` - [кольцевой буфер](../../Other/doc/datastructs/circular_buffer.md), его элементы не обязательно располагаются в памяти непрерывно. Если требуется получить один фрагмент данных, например для эффективной сортировки, то можно использовать [`make_contiguous`](https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.make_contiguous), который вернет изменяемый срез `VecDeque` непрерывных элементов.

### [LinkedList](https://doc.rust-lang.org/std/collections/struct.LinkedList.html)

Является двусвязным списком, позволяет добавлять и доставать элементы из его концов за константное время. Несмотря на это, почти всегда лучше использовать `Vec` или `VecDeque`, потому что они, как правило, быстрее и эффективнее используют память и кэш ЦП.

`LinkedList` можно инициализировать из массива.

## Maps

### [HashMap](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html)

Хэш карта реализованна с помощью [квадратичного зондирования](../../Other/doc/alghoritms/quadratic_probing.md) и поиска [SIMD](https://ru.wikipedia.org/wiki/SIMD).

По умолчанию, хэш карта использует алгоритм хеширования, выбранный для обеспечения устойчивости к атакам [`HashDoS`](https://habr.com/ru/post/178955/). Алгоритм запускается случайным образом и предпринимаются разумные усилия для создания начального числа из высококачественного, безопасного источника случайных чисел, предоставленного хостом, буз блокировки программы. Из-за этого случайность начального числа зависит от качества вывода генератора случайных чисел системы при создании начального числа. В частности, начальные значения, созданные, когда [пул энтропии](https://en.wikipedia.org/wiki/Entropy_(computing)) системы аномально низок, например во время загрузки системы, может иметь более низкое качество.

Алгоритм хеширования на данный момент - [`SipHash 1-3`](https://en.wikipedia.org/wiki/SipHash), хотя может быть изменен в любой момент в будущем. Хотя его производительность довольно конкурентоспособна для ключей среднего размера, другие алгоритмы хеширования его превзойдут для небольших ключей, таких как целые числа, и наоборот, таких как длинные строки, хотя остальные алгоритмы обычно не защищают от `HashDos`.

Алгоритм хеширования может быть заменен на основе `HashMap` методов `default`, `with_hasher` и `with_capacity_and_hasher`. На [crates.io](https://crates.io/) доступно множество альтернативных [алгоритмов хеширования](https://crates.io/keywords/hasher)

Требуется, чтобы ключи реализовывали трейты `Eq` и `Hash`, хотя этого можно частично добиться путем `[derive(PArtialEq, Eq, Hash)]`. Если реализованны трейты самостоятельно, важно, чтобы выполнялось следующее свойство:

```rust
k1 == k2 -> hash(k1) == hash(k2)
```

Другими словами, если два ключа равны, их хеши тоже должны быть равны.

Логической ошибкой будет изменение ключа таким образом, что хэш ключа, определенный свойством `Hash`, или его равенством, определенным через `Eq`, изменяется, пока ключ находится на карте. Обычно это возможно через: `Cell`, `RefCell`, глобальное состояние, ввод-вывод, небезопасный код. Поведение, возникающее в результате такой логической ошибки, не указывается, но оно будет инкапсулировано для `HashMap` и не приедет к неопределенному поведению. Это может привести к панике, утечке информации, прерыванию, незавершению. 😵‍💫

Реализация хэш таблицы представляет собой порт Rust для [`SwissTable`](https://abseil.io/blog/20180927-swisstables) от Google. [оригинал на C++](https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h), [Обзор](https://www.youtube.com/watch?v=ncHmEUmJZf4)

#### Examples

```rust
use std::collections::HashMap;

fn main() {
// Type inference lets us omit an explicit type signature (which
    // would be `HashMap<String, String>` in this example).
    let mut book_reviews = HashMap::new();

    // Review some books.
    book_reviews.insert(
        "Adventures of Huckleberry Finn".to_string(),
        "My favorite book.".to_string(),
    );
    book_reviews.insert(
        "Grimms' Fairy Tales".to_string(),
        "Masterpiece.".to_string(),
    );
    book_reviews.insert(
        "Pride and Prejudice".to_string(),
        "Very enjoyable.".to_string(),
    );
    book_reviews.insert(
        "The Adventures of Sherlock Holmes".to_string(),
        "Eye lyked it alot.".to_string(),
    );

    // Check for a specific one.
    // When collections store owned values (String), they can still be
    // queried using references (&str).
    if !book_reviews.contains_key("Les Misérables") {
        println!("We've got {} reviews, but Les Misérables ain't one.",
        book_reviews.len());
    }

    // oops, this review has a lot of spelling mistakes, let's delete it.
    book_reviews.remove("The Adventures of Sherlock Holmes");

    // Look up the values associated with some keys.
    let to_find = ["Pride and Prejudice", "Alice's Adventure in Wonderland"];
    for &book in &to_find {
        match book_reviews.get(book) {
            Some(review) => println!("{book}: {review}"),
            None => println!("{book} is unreviewed.")
        }
    }

    // Look up the value for a key (will panic if the key is not found).
    println!("Review for Jane: {}", book_reviews["Pride and Prejudice"]);

    // Iterate over everything.
    for (book, review) in &book_reviews {
        println!("{book}: \"{review}\"");
    }
}
```

```
We've got 4 reviews, but Les Misérables ain't one.
Pride and Prejudice: Very enjoyable.
Alice's Adventure in Wonderland is unreviewed.
Review for Jane: Very enjoyable.
Adventures of Huckleberry Finn: "My favorite book."
Grimms' Fairy Tales: "Masterpiece."
Pride and Prejudice: "Very enjoyable."
```

`HashMap` можно инициализировать из массива

```rust
let solar_distance = HashMap::from([
    ("Mercury", 0.4),
    ("Venus", 0.7),
    ("Earth", 1.0),
    ("Mars", 1.5),
]);
```

`HashMap` реализует [`Entry`](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.entry) API, который позволяет использовать сложные методы получения, установки, обновления, удаления ключей и их значений

```rust
// type inference lets us omit an explicit type signature (which
// would be `HashMap<&str, u8>` in this example).
let mut player_stats = HashMap::new();

fn random_stat_buff() -> u8 {
    // could actually return some random value here - let's just return
    // some fixed value for now
    42
}

// insert a key only if it doesn't already exist
player_stats.entry("health").or_insert(100);

// insert a key using a function that provides a new value only if it
// doesn't already exist
player_stats.entry("defence").or_insert_with(random_stat_buff);

// update a key, guarding against the key possibly not being set
let stat = player_stats.entry("attack").or_insert(100);
*stat += random_stat_buff();

// modify an entry before an insert with in-place mutation
player_stats.entry("mana").and_modify(|mana| *mana += 200).or_insert(100);
```

Один из простых способов использования `HashMap` с пользовательским типом ключа - получить `Eq` и `Hash`. Мы так же должны вывести `PartialEq`.

### [BTreeMap](https://doc.rust-lang.org/std/collections/struct.BTreeMap.html)

Является упорядоченной картой на основе [B-дерева](https://en.wikipedia.org/wiki/B-tree). B-дерево представляет собой фундаментальный компромисс между эффективностью кэширования и фактическим сокращением объема работы, выполняемой про поиске. Теоретически бинарное дерево поиска `BST` является оптимальным выбором для отсортированной карты, поскольку идеально сбалансированное `BST` выполняет минимальное количество сравнений, необходимых для поиска элемента (log2(n)), однако на практике, способ, которым это делается, _очень_ неэффективен для современных компьютерных архитектур. В частности, каждый элемент хранится в своем собственном узле, выделенном в куче. Это означает, что каждая отдельная вставка вызывает освобождение в кучи, и каждое отдельное сравнение должно приводить к потере кэша.

Вместо этого, B-дерево заставляет каждый узел содержать элементы от B-1 до 2B-1 в непрерывном массиве. Делая это, мы уменьшаем количество освобождений в B раз и повышаем эффективность кэширования при поиске. Однако это означает, что при поиске в среднем прийдется проводить больше сравнений. Точное количество сравнений зависит от используемой стратегии поиска узлов. Для оптимальной эффективности кеша можно искать узлы линейно. Для оптимального поиска можно использовать бинарный поиск. В качестве компромисса можно было бы так же использовать линейный поиск, которой сначала проверяет только каждый i-тый элемент для некоторого набора i.

В настоящее время используемая реализация выполняет линейный поиск. Это обеспечивает превосходную производительность на небольших узлах элементов, который дешевы для сравнения. Однако в будущем возможна замена алгоритма.

Логической ошибкой будет изменение ключа таким образом, что порядок ключа относительно любого другого ключа, определенного свойством [`Ord`](https://doc.rust-lang.org/std/cmp/trait.Ord.html) изменится. Обычно это доступно через `Cell`, `RefCell`, глобальное состояние, ввод-вывод или небезопасный код. Поведение, возникающее в результате такой логической ошибки не указывается, но он будет инкапсулировано для `BTreeMap`, что не приведет к неопределенному поведению. Это может включить панику, неправильные результаты, прерывания, утечки памяти и незавершению. 😵‍💫

#### Examples

```rust
fn main() {
    use std::collections::BTreeMap;

    // type inference lets us omit an explicit type signature (which
    // would be `BTreeMap<&str, &str>` in this example).
    let mut movie_reviews = BTreeMap::new();

    // review some movies.
    movie_reviews.insert("Office Space",       "Deals with real issues in the workplace.");
    movie_reviews.insert("Pulp Fiction",       "Masterpiece.");
    movie_reviews.insert("The Godfather",      "Very enjoyable.");
    movie_reviews.insert("The Blues Brothers", "Eye lyked it a lot.");

    // check for a specific one.
    if !movie_reviews.contains_key("Les Misérables") {
        println!("We've got {} reviews, but Les Misérables ain't one.",
                movie_reviews.len());
    }

    // oops, this review has a lot of spelling mistakes, let's delete it.
    movie_reviews.remove("The Blues Brothers");

    // look up the values associated with some keys.
    let to_find = ["Up!", "Office Space"];
    for movie in &to_find {
        match movie_reviews.get(movie) {
        Some(review) => println!("{movie}: {review}"),
        None => println!("{movie} is unreviewed.")
        }
    }

    // Look up the value for a key (will panic if the key is not found).
    println!("Movie review: {}", movie_reviews["Office Space"]);

    // iterate over everything.
    for (movie, review) in &movie_reviews {
        println!("{movie}: \"{review}\"");
    }
}
```

```
We've got 4 reviews, but Les Misérables ain't one.
Up! is unreviewed.
Office Space: Deals with real issues in the workplace.
Movie review: Deals with real issues in the workplace.
Office Space: "Deals with real issues in the workplace."
Pulp Fiction: "Masterpiece."
The Godfather: "Very enjoyable."
```

Можно инициализировать из массива.

## Sets

### [HashSet](https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html)

### [BtreeSet](https://doc.rust-lang.org/std/collections/struct.BTreeSet.html)

## Misc

### [BinaryHeap](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html)

# Examples

## Использование `entry`

Здесь используется `BTreeMap` для того, чтобы хранить количества каждого символа в строке.

```rust
use std::collections::btree_map::BTreeMap;

fn main() {
    let mut count = BTreeMap::new();
    let message = "she sells sea shells by the sea shore";

    for symbol in message.chars() {
        *count.entry(symbol).or_insert(0) += 1;
    }

    assert_eq!(count.get(&'s'), Some(&8));

    for (char, count) in &count {
        println!("{}: {}", char, count);
    }
}
```

```
 : 7
a: 2
b: 1
e: 7
h: 4
l: 4
o: 1
r: 1
s: 8
t: 1
y: 1
```

## Использование сложных ключей для BTreeMap

Если используются сложные значения, что вызов `insert` не будет обновлять значение ключа.

```rust
use std::{
    cmp::Ordering,
    collections::BTreeMap,
    hash::{
        Hash,
        Hasher
    }
};

#[derive(Debug)]
struct Foo {
    a: u32,
    b: &'static str,
}

impl PartialEq for Foo {
    fn eq(&self, other: &Self) -> bool { self.a == other.a }
}

impl Eq for Foo {}

impl Hash for Foo {
    fn hash<H: Hasher>(&self, state: &mut H) { self.a.hash(state); }
}

impl PartialOrd for Foo {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> { self.a.partial_cmp(&other.a) }
}

impl Ord for Foo {
    fn cmp(&self, other: &Self) -> Ordering { self.a.cmp(&other.a) }
}

fn main() {
    let mut map = BTreeMap::new();
    map.insert(Foo {a: 1, b: "baz"}, 99);

    map.insert(Foo {a: 1, b:"xyz"}, 100);

    assert_eq!(map.values().next().unwrap(), &100);
    assert_eq!(map.keys().next().unwrap().b, "baz");
}
```

---
