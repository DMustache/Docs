# OOP

## Abstraction

Использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи. Позволяет работать с объектами, не вдаваясь в особенности их реализации. Пользователь типа данных не имеет прямого доступа к его реализации, но может работать с данными через предоставленный набор операций. Преимущество абстракции данных в разделении операций над данными и внутреннего представления этих данных, что позволяет изменять реализацию, не затрагивая пользователей типа данных.

Абстракция — способность скрывать детали различных реализаций некоторого функционала под общим интерфейсом и, затем использовать их в общем для всех реализаций коде. Собрав воедино код всех примеров с формами мы получим пример абстракции.

Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерён в коробке передач или влияния формы кузова на скорость.

## Inheritance

Наследование — это механизм, с помощью которого объект может наследовать элементы из определения другого объекта, таким образом получая данные и поведение родительского объекта без необходимости их повторного определения.

Например "Утка - плавающая птица" показывает, что некий класс "Утка" наследуется от некой "плавающей птицы". При этом дочерний объект может быть использован в любом контексте, в котором ожидается родительский объект.

### Примеры

#### C#

Наследование от одного класса и двух интерфейсов

```c#
public class A { }
public interface I1 { }
public interface I2 { }
public class B : A, I1, I2 { }
```

Наследование вложенных классов от классов, их содержащих

```c#
class A // default class A is internal, not public class B can not be public
{
    class B : A { }
}
```

#### Rust

Если язык должен иметь наследование, чтобы быть объектно-ориентированным, то Rust им не является. Невозможно определить структуру, которая наследует поля и реализации методов родительской структуры, без использования макроса. Однако, если вы привыкли иметь наследование в своем наборе инструментов для программирования, вы можете использовать другие решения в Rust, в зависимости от того, по какой причине вы изначально стремитесь к наследованию.

```rust
trait Shape {
    // У любой формы можно посчитать площадь.
    fn area(&self) -> f32;
}

trait HasAngles: Shape {
    // У любой фигуры с углами можно посчитать количество углов.
    fn angles_count(&self) -> i32;
}

struct Rectangle {
    x: f32,
    y: f32,
}

// Прямоугольник является формой.
impl Shape for Rectangle {
    fn area(&self) -> f32 {
        self.x * self.y
    }
}

// Прямоугольник является фигурой с углами.
impl HasAngles for Rectangle {
    fn angles_count(&self) -> i32 {
        4
    }
}

struct Circle {
    r: f32,
}

// Круг является формой
impl Shape for Circle {
    fn area(&self) -> f32 {
        self.r.pow(2) * PI
    }
}
```

---

## Polymorphism

Полиморфизмом называется возможность функции получать и обрабатывать данные разных типов

### Примеры

Например, подумайте о базовом классе с именем `Animal`, у которого есть метод с именем `animalSound()`. Производными классами животных могут быть Свиньи, Кошки, Собаки, Птицы. И у них также есть собственная реализация звука животного (свинья хрюкает, кошка мяукает и т. д.):

#### C#

```c#
class Animal  // Base class (parent)
{
    public virtual void animalSound()
    {
        Console.WriteLine("The animal makes a sound");
    }
}

class Pig : Animal  // Derived class (child)
{
    public override void animalSound()
    {
        Console.WriteLine("The pig says: wee wee");
    }
}

class Dog : Animal  // Derived class (child)
{
    public override void animalSound()
    {
        Console.WriteLine("The dog says: bow wow");
    }
}
```

#### Rust

Статический полиморфизм требует, чтобы при компиляции программы было известно, какие конкретные типы используются в каждом обобщённом контексте. Имея эту информацию компилятор проводит, так называемую, мономорфизацию. Когда одна обобщённая сущность превращается в несколько сущностей с конкретными типами, используемыми в них. При этом размер исполняемого файла раздувается и мы теряем возможность подменять наследника в процессе выполнения программы. Взамен получаем более высокую скорость выполнения, так как компилятору известны конкретные типы и адреса функций для каждой ситуации, а следовательно, он может применять больше оптимизаций.

```rust
// Принимаем что угодно, реализующее трейт Shape.
fn areas_sum(shape1: impl Shape, shape2: impl Shape) -> f32 {
    shape1.area() + shape2.area()
}

fn foo(rectangle: Rectangle, circle: Circle) {
    // Можем передать две разные фигуры.
    let sum = areas_sum(rectangle, circle);
}
```

Динамический полиморфизм работает иначе. Здесь этом мы не знаем конкретного типа объекта и для получения адреса его методов в памяти используем дополнительную информацию — таблицу функций. Её содержимое зависит от того, какой конкретный тип скрывается за абстрактным указателем. Такой подход не раздувает исполняемый файл и позволяет подменять реализацию в процессе выполнения программы. Но при этом мы жертвуем частью производительности — для вызова метода нам придётся сначала прочитать его адрес из памяти, что значительно затрудняет оптимизацию программы на этапе компиляции.

```rust
// Принимаем что угодно, реализующее трейт Shape.
// В этот раз принимаем не сами объекты, а ссылки на них,
// так как не зная конкретный тип объекта, мы не знаем и его размер,
// а следовательно, не сможем выделить для него место на стеке.
fn areas_sum(shape1: &dyn Shape, shape2: &dyn Shape) -> f32 {
    shape1.area() + shape2.area()
}

fn foo(rectangle: Rectangle, circle: Circle) {
    // Можем передать ссылки на две разные фигуры.
    let sum = areas_sum(&rectangle, &circle);
}
```

## Encapsulation

Инкапсуляция означает, что детали реализации объекта недоступны для кода, использующего этот объект. Поэтому единственный способ взаимодействовать с объектом — через его общедоступный API. Код, использующий объект, не должен иметь возможности проникнуть внутрь объекта и напрямую изменить данные или поведение. Это позволяет программисту изменять и реорганизовывать внутреннее устройство объекта без необходимости изменения кода, который использует объект.

это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали
реализации от пользователя.

### Примеры

#### C#

Целью инкапсуляции является обеспечение согласованности внутреннего состояния объекта. В C# для инкапсуляции используются публичные свойства и методы объекта. Переменные, за редким исключением, не должны быть публично доступными. Проиллюстрировать инкапсуляцию можно на простом примере. Допустим, нам необходимо хранить вещественное значение и его строковое представление. Пример реализации без инкапсуляции таков:

```c#
class NoEncapsulation
{
    public double ValueDouble;
    public string ValueString;
}
```

При этом мы можем отдельно изменять как само значение Value, так и его строковое представление, и в некоторый момент может возникнуть их несоответствие (например, в результате исключения). Пример реализации с использованием инкапсуляции:

```c#
class EncapsulationExample
{
    private double valueDouble;
    private string valueString;

    public double ValueDouble
    {
        get { return valueDouble; }
        set
        {
            valueDouble = value;
            valueString = value.ToString();
        }
    }

    public string ValueString
    {
        get { return valueString; }
        set
        {
            double tmp_value = Convert.ToDouble(value); //здесь может возникнуть исключение
            valueDouble = tmp_value;
            valueString = value;
        }
    }
}
```

#### Rust

Инкапсуляция — сокрытие внутренней реализации объекта от внешнего пользователя. В Rust эта идея реализуется с помощью приватных полей и методов структур, используя механизм модулей. Если поле или метод в структуре не помечен как публичный, то для любого внешнего модуля это поле является скрытым и не может быть использовано. Более того, чтобы саму структуру было видно извне её модуля, её тоже нужно помечать, как публичную. Пример:

```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}

impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```

Общедоступные методы `add`, `remove` и `average` являются единственными способами доступа или изменения данных в экземпляре `AveragedCollection`. Когда элемент добавляется к `list` использованию `add` метода или удаляется с помощью `remove` метода, реализации каждого вызывают закрытый метод, который также `update_average` обрабатывает обновление поля `average`.

Мы оставляем поля `list` и `average` закрытыми, чтобы внешний код не мог напрямую добавлять или удалять элементы поля. В противном случае `average` поле может рассинхронизироваться при `list` изменении. Метод `average` возвращает значение в `average `поле, позволяя внешнему коду читать, `average` но не изменять его.

---